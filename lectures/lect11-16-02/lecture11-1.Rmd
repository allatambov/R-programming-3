---
title: "Основы программирования в R"
subtitle: "Лекция 11. Управляющие конструкции."
author: "Алла Тамбовцева"
date: '16 февраля 2018 г '
output: html_document
---

## Вывод сообщения на экран

В R для вывода сообщения на экран есть две функции: `print()` и `cat()`. С `print()` мы уже знакомы:

```{r}
print(2)
print("Welcome to R")
```

Как можно заметить, когда с помощью `print()` на экран выводится текст, он печатается в кавычках. При желании это можно изменить, добавив аргумент `quote`:
```{r}
print("Welcome to R", quote = FALSE)
```

А что делает `cat()`? Тоже выводит сообщение на экран, только сразу без кавычек:
```{r}
cat("Welcome to R")
```

Видно, что `cat()` при печати к тому же не выводит номер строки. Но это все мелочи. В чем состоит принципиальное отличие `print()` от `cat()`? Во-первых, `cat()`, в отличие от `print()`, умеет "склеивать" то, что мы подаем ему на вход. Сравним:
```{r}
print(2, 3, 4) # выводится только первый элемент
cat(2, 3, 4) # выводятся все три элемента
```

Во-вторых, `cat()` умеет работать только с одномерными объектами (те, что называются в R *atomic objects*), а `print()` может вывести на экран что угодно. 

Оба работают: 
```{r}
vec <- c(2, 3, 4)
cat(vec)
print(vec)
```
Здесь `cat` выводит что-то не то:
```{r}
m <- matrix(nrow = 2, ncol = 3, 3)
cat(m)
print(m)
```
А здесь `cat` просто ломается:
```{r}
l <- list(c(1, 2, 3), c(0, 1))
# cat(l)
print(l)
```

В-третьих, `cat()` просто выводит объект на экран, не сохраняя информацию о нем, а `print()` сохраняет тип объекта:
```{r}
class(cat(vec)) # тип NULL
class(print(vec)) # тип numeric, как у самого вектора
```

Как быть, если мы хотим вывести некоторый текст и значение переменной? Для этого можем использовать `cat()`, потому что он умеет "склеивать" записи:
```{r}
name <- "Ann"
cat("Your name is", name)
```

А если мы хотим, чтобы переменная была где-то внутри текста? Для этого есть функция `sprintf()`:
```{r}
name <- "Ann"
age <- 25
print(sprintf("Your name is %s. Your age is %i", name, age))
```

В то место, куда мы хотим добавить значение переменной, мы вписываем знак `%` и сокращенное название типа это переменной: `s` для строк (*string*), `i` - для целочисленных (*integer*), `f` - для чисел с плавающей точкой (*float*). У чисел с плавающей точкой можно контролировать число знаков после запятой:

```{r}
height <- 125.768
print(sprintf("Your height is %f.", height)) # по умолчанию 6 знаков
print(sprintf("Your height is %.3f.", height)) # три знака
print(sprintf("Your height is %.2f.", height)) # два знака (округляется)
```

И теперь, чтобы оживить лекцию, обсудим ввод с клавиатуры. Как быть, если мы хотим запрашивать информацию у пользователя, а затем ее использовать? Для этого есть функция `readline()`. Чтобы понять, как она работает, проще всего посмотреть на пример:

```{r}
input <- readline(prompt = "Enter something: ") # вводим число 45 в консоль
input
```

Число, которое мы ввели с клавиатуры в консоль, сохранилось в переменную `input`. Но есть проблема: R не понимает, что перед ним число:

```{r}
class(input)
```

Но исправлять такие вещи мы умеем.

```{r}
as.integer(input)
```

А что делать, если введено сразу несколько элементов, например несколько чисел через пробел?

```{r}
inputs <- readline(prompt = "Enter something: ") # 2 3 4
inputs
```

Воспользуемся функцией `strsplit`, которую мы когда-то обсуждали, и разобьем получившуюся строку по пробелу:

```{r}
l <- strsplit(inputs, " ") # пока список (list)
v <- unlist(l) # теперь вектор
v <- as.numeric(v) # сделаем числовым
```

## Управляющие конструкции в R: условия

Для того, чтобы в R осуществлял различные действия в зависимости от того, выполняется ли определенное условие или нет, понадобятся операторы условия: `if` и `else`. Например, мы сохраняем в R оценку по курсу и хотим, чтобы он выводил на экран "Good!" и "You are genious!", если она больше 5 и "Bad!" во всех остальных случаях.
```{r}
mark <- 6
if (mark > 5){
  print("Good!") 
  print("You are genious!")
  }else print("Bad!")
```

Само условие записывается в круглых скобках, то, что R должен сделать в случае, если условие выполняется, -- в фигурных. 

Если в случае выполнения условия R должен сделать что-то, что умещается в одну строчку кода, фигурные скобки можно опустить (и вообще все записать в одну строчку):

```{r}
if (mark > 5) print("Good!") else print("Bad!")
```

Часть кода с `else` не является обязательной: если требуется что-то сделать только с случае выполнения условия, `else` можно совсем опустить. 

```{r}
mark <- 3
if (mark > 5) print("Good!") # просто ничего не происходит
```

Иногда мы сталкиваемся с необходимостью использовать множественные условия (например, какие-то два условия должны выполняться одновременно). Для этого потребуются те же символы, которые используются в логических выражениях (&, |).

```{r}
mark <- 7
if (mark < 4) print("Bad.") else {
if (mark >= 4 & mark < 6) print("Not bad.")
if (mark >= 6 & mark < 8) print("Good.")
if (mark >= 8) print("Excellent.")}
```

```{r}
mark <- 10
if (mark == 8 | mark == 9 | mark == 10) print("Excellent.") # хотя бы одно условие выполняется
```
