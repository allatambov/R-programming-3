---
title: "Основы программирования в R"
subtitle: "Лекция 3. Базы данных в R."
author: "Алла Тамбовцева"
date: '24 ноября 2017 г '
output: html_document
---

Изучив основные объекты в R, мы можем перейти к объектам, ради которых многие и начинают изучать R, а именно, к базам данных. Но прежде необходимо научиться загружать файлы с данными, чтобы было с чем работать.

## Работа с файлами

### Загрузка данных в R

**Повторение.** Если мы не хотим прописывать слишком длинный путь к файлу, файл с данными можно сохранить сразу в рабочую папку (папку, из которой запускается R). Тогда при попытке открыть файл с заданным названием R будет искать его в этой папке. Узнать, какая папка является рабочей, можно с помощью функции `getwd()`:

```{r}
getwd() # wd - от working directory
```

Рабочую папку можно изменить. Например, так: 
```{r, eval=FALSE}
setwd("C:/AllaT/Рабочий стол/")
```

Для начала загрузим в R "простые" текстовые файлы. "Простые" в том смысле, что для их загрузки не требуется установки специальных библиотек.

**csv-файлы**

Формат csv (comma separated values) - широко распространенный текстовый формат, который используется для представления табличных данных. В качестве разделителя, т.е. символа, который разделяет значения колонок, обычно используется запятая, как и следует из названия. 
```{r}
df <- read.csv("example1.csv")
View(df) # посмотреть на базу данных, V - заглавная
```
Но иногда в качестве разделителя могут быть использованы другие символы (точка с запятой, пробел, табуляция). Если мы загрузим файл с другим разделителем и никак это не укажем, что загрузится совсем не то, что мы ожидали:
```{r}
df1 <- read.csv("example2.csv")
View(df1)
```
А если выставим нужный разделитель в качестве параметра, то все будет, как нужно:
```{r}
df1 <- read.csv("example2.csv", sep = ";") # sep - от separator
View(df1)
```
Если в файле есть текст на кириллице, могут возникнуть проблемы при чтении файла или при его отображении. Решения могут быть разными (зависит от системы, ее параметров и самого файла). Вот некоторые из них.

Можно посмотреть, какая кодировка и какие языки определены системой по умолчанию:
```{r}
Sys.getlocale()
```
Можно добавить русский язык:
```{r}
#Sys.setlocale("Russian")
```
А можно просто спеифицировать кодировку самого файла:
```{r}
#df2 <- read.csv("example3.csv", encoding = "UTF-8")
#df2 <- read.csv("example4.csv", encoding = "WINDOWS-1251")
```

Будем считать, что с csv-файлами разобрались.

**txt-файлы**

При работе с txt-файлами необходимо указывать, каким образом столбцы отделены друг от друга (аргумент `sep`, разделитель, как и в случае в csv-файлами), а также учитывать, что представляет собой первая строка: наблюдение или шапку таблицы (аргумент `header`). Откроем файл, в котором столбы разделены табуляцией и сравним, как он будет выглядеть при выставлении разных значений параметра `header`:
```{r}
table1 <- read.table('example1.txt', sep='\t', header = TRUE)  
View(table1) # header = T - первая строка читается как имя переменной

table2 <- read.table('example1.txt', sep='\t', header = FALSE)
View(table2) # header = F - первая строка читается как наблюдение
```

Теперь перейдем к другим форматам.

**файлы Excel**

Чтобы спокойно загружать xls-файлы и xlsx-файлы необходимо установить соответствующие библиотеки `xls` (`xlsx`). 

Установим библиотеку `xlsx`. С ее установкой могут возникнуть проблемы: R будет писать что-то про rjava. Это обычно бывает, если на компьютере не установлена Java или установлена такая ее версия, которая конфликтует с R (например, недостаточно новая). Тогда Java можно поставить, скачав [отсюда](https://www.java.com/en/download/manual.jsp).  После этого проблема должна исчезнуть.

```{r, eval=FALSE}
install.packages("xlsx")
```
Теперь обратимся к этой библиотеке - иначе открыть файл мы не сможем:
```{r, message=FALSE}
library(xlsx)
```

Наконец, откроем сам файл. Не забудьте указать номер листа после запятой (даже если он всего один), иначе не сработает.

```{r}
ex_data <- read.xlsx("example1.xlsx", 1)
```

**файлы STATA**

Для загрузки файлов STATA (файлы с расширением `.dta`) потребуется библиотека `foreign`.

```{r, eval = FALSE}
install.packages("foreign")
```
```{r, message = FALSE}
library(foreign)
```

Теперь загрузим dta-файл.
```{r}
stata_data <- read.dta("example1.dta")
```

**файлы SPSS**

Для загрузки файлов SPSS (файлы с расширением `.sav`) потребуется библиотека `Hmisc`.
```{r, eval = FALSE}
install.packages("Hmisc")
```
```{r, message=FALSE}
library(Hmisc)
```
Загрузим sav-файл.
```{r}
#sav_data <- spss.get("example1.sav")
```

### Сохранение файлов

Выгружаются данные из R аналогичным образом, но только вместо `read` в названиях функций используется `write`. Например, сохраним базу df в csv-формате:
```{r}
write.csv(df, "new_file.csv")
```

## Работа с базами данных

### Описание базы данных

Загрузим более содержательную базу данных. Базу данных, которая использовалась в исследовании Druckman, Levendusky, McLain *No Need to Watch: How the Effects of Partisan Media Can Spread via Inter-Personal Discussions* (2017). Файл и codebook к базе данных можно найти [здесь](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/TJKIWN).

```{r}
dat <- read.csv("druckman_levendusky_mclain.csv")
```

Какую информацию о базе данных мы можем получить?

Можем определить число наблюдений и число переменных в базе. Узнать это можно точно так же, как и размерность матрицы, ведь число строк - это число наблюдений, а число столбцов - это число переменных.

```{r}
dim(dat)
```

Можем узнать гораздо больше - структуру базы данных: число наблюдений и переменных, типы переменных и примеры значений, которые они принимают. Сделать это можно с помощью уже знакомой функции `str()`:
```{r}
str(dat)
```
Также легко посмотреть на первые несколько значений:
```{r}
head(dat)
```

Или последние:
```{r}
tail(dat)
```

Обсуждение вывода описательных статистик для переменных в базе данных оставим на потом, разберем этот вопрос более подробно, когда начнем разведывательный анализ данных. А пока поговорим о чуть более продвинутых (но несложных!) вещах.

### Пропущенные значения

Результаты, которые выдают нам функции `str()` и `dim()`, содержат только общую информацию о количестве наблюдений в базе данных и не дают никакой информации о пропущенных значениях. Как это исправить? Для начала можно выяснить, сколько в базе неполностью заполненных строк. Функция `complete.cases()` выдает логический вектор, где TRUE означает полностью заполненную строку, а FALSE - содержащую пропуски (NAs). 
```{r}
head(complete.cases(dat)) # head - первые несколько значений
```
Посчитаем, сколько полностью заполненных наблюдений:
```{r}
sum(complete.cases(dat))
```
Соответственно, остальные (из 575)  - недозаполненные (содержащие NAs).

Посмотрим на незаполненные строки:
```{r}
View(dat[!complete.cases(dat), ]) # ! отрицание
```

Для дальнейшей работы с пропущенными значениями нам понадобятся дополнительные библиотеки. Установим их. Можно устанавливать сразу несколько библиотек -- оформить перечень необходимых библиотек в виде вектора, и тогда сразу после установки одной библиотеки начнется загрузка следующей. 

```{r, eval=FALSE}
install.packages(c("mice", "VIM"))
```
Обратимся к ним:
```{r, message=FALSE}
library(mice)
library(VIM)
```

Выведем графики, которые покажут, в каких переменных пропущенных значений больше всего и как выглядит база с пропущенными значениями (паттерны пропущенных значений).

На графике слева показано, с какой частотой встречаются пропущенные значения в той или иной переменной. На графике справа показано, в каких комбинациях эти пропущенные значения встречаются. Например, в нашем случае отсутствие ответов в TrustOther часто совпадает с отсутствием ответов в KnowOther (пропущенные значения отмечены красным цветом).
```{r}
aggr(dat)
```

Следующий график отвечает за заполненность наблюдений (красным цветом отмечены пропущенные значения, остальное - заполненные значения, чем темнее цвет, тем больше значение). По вертикальной оси - номер строки в базе данных (id наблюдения).
```{r}
matrixplot(dat) 
```

**Удаление пропущенных значений**

При работе с базами данных необходимо удалить пропущенные значения (или правильно заполнить - кто умеет), потому что иначе мы не сможем полноценно работать с базой (многие функции не работают при наличии NAs, а у некоторых необходимо указывать дополнительный аргумент - учитывать NA или нет).
```{r}
dat <- na.omit(dat)
```

### Выбор переменных 

Если мы хотим обратиться к конкретной переменной и рассматривать ее как вектор элементов, нужно использовать символ `$`.
```{r}
dat$Educ # образование
```

**Attach и detach**

Мы можем "закрепить" базу данных с помощью команды *attach*, чтобы обращаться к переменным более простым способом:
```{r}
attach(dat) # заодно покажет, какие переменные есть
head(Educ) # имя переменной как есть, без $
Educ
```
Однако это не всегда удобно, особенно если приходится работать с несколькими базами одновременно (наложение переменных с одинаковыми именами, проблемы с редактированием и прочее).
```{r}
detach(dat) # возвращаем обратно
```
### Создание и добавление в базу новых переменных

Допустим, мы хотим добавить в базу переменную Session. Для этого нужно через $ задать имя новой переменной и присвоить ей значение: 
```{r}
dat$Session <- factor(dat$Type_of_Session)
View(dat)
```


### Фильтрация наблюдений

Часто при работе с данными возникает необходимость выбрать несколько переменных или определенную группу наблюдений и анализировать их отдельно - чтобы не загружать каждый раз огромную базу с ненужными показателями. 

Можем выбрать несколько переменных (столбцов) и сохранить их в другую базу:
```{r, eval=FALSE}
dat[2:4] # 2 и 4 - порядковые номера столбцов, от 2 до 4
```
Получится маленькая база из трех переменных. 
И сохраним как новую базу dat1:
```{r}
dat1 <- dat[2:4] 
View(dat1)
```
Если выбираем столбцы не подряд, обязательно их номера нужно оформить в виде вектора:
```{r, eval=FALSE}
dat[c(1, 3)] # не просто dat[1, 3]
```
В противном случае получится совсем не то:
```{r}
dat[1, 3] 
```
Это "совсем не то" связано с тем, что, когда мы указываем в квадратных скобках числа через запятую, R воспринимает первое число как номер строки, второе число - как номер столбца (как в матрицах - сначала строка, потом столбец). Можем посмотреть на исходную базу и убедиться в этом:
```{r}
View(dat)
```
Но таким образом мы можем выбирать строки (наблюдения):
```{r, eval=FALSE}
dat[, 1:3] # берем все наблюдения (строки), первые 3 переменные (столбцы)
```
Или столбцы:
```{r, eval=FALSE}
dat[1:4, ] # берем первые 4 наблюдения (строки), все переменные (столбцы)
```

**Фильтрация по условиям**

Если хотим отобрать из базы определенные наблюдения, это тоже можно сделать с помощью `subset()` ("фильтры"). Например, хотим выбрать респондентов с определенным уровнем образования: 
```{r}
sub_educ <- subset(dat, Educ >= 3)
View(sub_educ)
```
Для указания нескольких условий опять потребуются логические операторы:
```{r}
y <- subset(dat, Educ >= 3 & Female == 0) # несколько условий
View(y)
```
Конечно, можем отбирать наблюдения и переменные одновременно:
```{r}
z <- subset(dat, Educ >= 3 & Female == 0, select = c(Group_Number, Educ, Female)) 
View(z)
```

### Удаление переменных

Чтобы удалить переменные, можно действовать двумя способами:

1) удалить их из базы

2) оставить все остальные переменные в базе

По смыслу это одно и то же. И то, и другое чаще всего осуществляется с помощью функции `subset()`.

Допустим, мы хотим выбрать переменные Educ и Female и сохранить их в новую базу:
```{r}
dat <- subset(dat, select = c(Educ, Female)) # указываем имя базы, оставляем Educ и Female
View(dat)
```
А теперь хотим оставить все, кроме переменной Educ:
```{r}
dat1 <- subset(dat, select = -Educ) # перед ней стоит минус
View(dat1)
```