---
title: "Основы программирования в R"
subtitle: "Лекция 4. Работа с базами данных с использованием dplyr."
author: "Алла Тамбовцева"
date: '08 декабря 2017 г '
output: html_document
---

Библиотека `dplyr` - библиотека для удобной работы с базами данных. С ее помощью можно более быстро получать описание базы данных, сохранять полученные результаты и группировать данные по определенному признаку. Научиться работать с это библиотекой несложно, нужно только понять общую логику, познакомиться с особыми операторами и функциями, а также немного попрактиковаться. 

Для начала установим библиотеку и обратимся к ней:

```{r, eval=FALSE}
install.packages("dplyr")
```
```{r, message=FALSE}
library(dplyr)
```

Теперь мы готовы к работе. Загрузим базу с результатами плебисцита в Чили, с которой мы работали на прошлом семинаре.
```{r}
chile <- read.csv("Chile.csv") 
```

### Основные функции dplyr и оператор %>%

Некоторые функции, встроенные в библиотеку, похожи на обычные функций, которые мы использовали на прошлом занятии. Например, функция `select()`, которая позволяет выбрать интересующие нас столбцы в базе данных:
```{r}
sh_chile <- select(chile, sex, age, income, vote)
View(sh_chile) 
```
Также с помощью `select()` можем исключить некоторые столбцы, которые нас не интересуют, поставив перед вектором столбцов минус (так же, как и раньше!):
```{r}
sh_chile2 <- select(chile, -c(X, region, population))
View(sh_chile2)
```

Столбцы можно выбирать по названиям, если столбцы идут подряд:
```{r}
head(select(chile, sex:vote)) # столбцы от sex до vote
```

Если хотим отобрать интересующие нас наблюдения, нам потребуется другая функция - `filter()`. Отберем, например, респондентов не моложе 45 лет:

```{r}
old_ch <- filter(chile, age >= 45)
View(old_ch)
```
А теперь отберем респондентов мужского пола, не моложе 45 лет:
```{r}
old_ch <- filter(chile, age >= 45 & sex == "F")
View(old_ch)
```

Казалось бы, зачем использовать библиотеку `dplyr`, если результаты пока несильно отличаются от того, что мы делали на прошлом занятии без всяких библиотек? На самом деле, смысл использовать ее есть. И сейчас мы переходим к самому интересному.

В библиотеке `dplyr` есть особый оператор `%>%`, который позволяет выполнять операции пошагово. Смысл этого оператора такой: возьми, то, что слева от `%>%`и передай это на вход функции, стоящей справа от `%>%`. Посмотрим на простом примере:
```{r}
chile %>% View
```
Взять базу `chile` и подать ее на вход функции `View`. Как можно заметить, во `View` уже нет ни скобок, ни названия базы, потому что они и не нужны -- R и так знает, с чем ему работать.

Рассмотрим другой пример. Возьмем базу `chile`, сначала выберем столбцы sex, age, income и vote, а потом запросим несколько первых строк базы:
```{r}
chile %>% 
  select(sex, age, income, vote) %>% 
  head
```

В библиотеке `dplyr` есть несколько других интересных и полезных функций. Например, `arrange()` -- функция, которая сортирует базу данных в соответствии со значениями переменной (или переменных), расположенных по возрастанию (если переменная текстовая, то по алфавиту). Отсортируем базу по показателю `statusquo` и посмотрим на первые несколько строк:

```{r}
chile %>% arrange(statusquo) %>% head
```
А теперь на последние:
```{r}
chile %>% arrange(statusquo) %>% tail
```

Другая полезная функция -- `mutate()` -- используется для создания и добавлению в базу данных новой переменной. Создадим переменную `log_income` -- натуральный логарифм дохода респондентов.
```{r}
chile %>% 
  mutate(log_income = log(income)) %>%
  View
```

Если теперь мы посмотрим на базу `chile` привычным образом, нас будет ждать сюрприз:
```{r}
View(chile)
```
Переменной `log_income` в базе нет! Почему? Дело в том, что когда мы проделываем что-то с базой с помощью `dplyr` и не сохраняем результат, изменения в самой базе не происходят. Как сохранить изменения? Очень просто: как всегда, сохранить результат в переменную, в которой хранится база:
```{r}
chile <- chile %>% 
  mutate(log_income = log(income))
```

Добавлять можно и более одной переменной за раз:
```{r}
chile <- chile %>% 
  mutate(log_income = log(income), log_population = log(population))
View(chile)
```

Теперь у нас в базе данных есть две переменные, которые начинаются с `log`. В `dplyr` есть функция, которая позволяет выбрать столбцы, названия которых начинаются одинаково.
```{r}
chile %>% 
  select(starts_with("log_")) %>%
  head 
```

Чтобы закрепить то, что мы уже успели разобрать, рассмотрим две задачи. 

**Задача 1.** Выбрать строки в базе, для которых значения `statusquo` не пустые (не NA) в переменной `statusquo`, выбрать респондентов с доходом свыше 35000, отсортировать строки в базе по возрасту респондентов и посмотреть на базу данных.

Решение.

```{r}
chile %>% 
  filter(!is.na(statusquo), income > 35000) %>% 
  arrange(age) %>% 
  View
```

Сначала мы выберем те строки в базе, для которых значения `statusquo` не пустые (`is.na` и помним про отриание - восклицательный знак), а заодно выберем респондентов с доходом более 35000. Затем с помощью `arrange()` отсортируем строки по значениям `age`. И, наконец, посмотрим на базу данных через `View`.

**Задача 2.** Выбрать строки в базе, для которых значения `statusquo` не пустые (не NA), выбрать тех респондентов, которые голосовали за или против Пиночета (значения 'Y' или 'N' в `vote`), выбрать столбцы `region`, `statusquo` и `vote`, а затем вывести на экран первые 10 строк.

```{r}
chile %>% 
  filter(!is.na(statusquo), vote == "Y" |  vote == "N") %>% 
  select(region, statusquo, vote) %>%
  head(10)
```

### Функции summarize(), group_by() и tally

Сейчас речь пойдет, пожалуй, о самых полезных функциях dplyr :)

При работе с данными мы часто сталкиваемся с тем, что нам нужно получить какую-то сводную информацию по переменным. Для этого существует функция `summarise()`. Попробуем пока получить общее число строк в базе данных:
```{r}
chile %>% summarise(total = n())
```

Функция `n()` универсальна, она используется для подсчета элементов. К ней мы еще вернемся.

Теперь сделаем что-нибудь более интересное. Определим минимальное, максимальное и среднее значение возраста респондентов в этой базе. 

```{r}
chile %>% summarise(avg_age = mean(age), 
                    min_age = min(age), 
                    max_age = max(age))
```

Почему R не хочет ничего считать? Потому что в переменно `age` есть пропущенные значения! Как справиться с этой проблемой? Самое простое и очевидное -- удалить NA из базы. Но это необязательно. У многих функций в R, работающих с переменными, есть параметр `na.rm`, который позволяет зафиксировать, исключать ли пропущенные значения (*rm - remove*) при подсчете или нет.

```{r}
chile %>% summarise(avg_age = mean(age, na.rm = TRUE), 
                    min_age = min(age, na.rm = TRUE), 
                    max_age = max(age,na.rm = TRUE))
```

Теперь все в порядке.

Часто необходимо получить сводную информацию не по всем наблюдениям в базе, а по определенной группе. Для этого сначала нужно сгруппировать данные, основываясь на значениях какой-нибудь переменной. Воспользуемся функцией `group_by()` и посмотрим, сколько в базе респондентов из разных регионов: 

```{r}
chile %>% group_by(region) %>% summarise(count_reg = n())
```

А теперь посмотрим на средний возраст респондентов из разных регионов:

```{r}
chile %>% group_by(region) %>% summarise(avg_income = mean(age, na.rm = TRUE))
```

Число наблюдений можно посчитать и по-другому -- с помощью функции `tally`:
```{r}
chile %>% group_by(sex) %>% summarise(count_sex = n())
chile %>% group_by(sex) %>% tally()
```






