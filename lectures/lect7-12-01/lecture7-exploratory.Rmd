---
title: "Основы программирования в R"
subtitle: "Лекция 6. Разведывательный анализ данных."
author: "Алла Тамбовцева"
date: '12 января 2017 г '
output: html_document
---

## Подготовка базы данных

На этой лекции мы будем работать с базой данных, содержащей результаты выборов президента в 2012 году.

Для начала приведем эту базу данных к более удобному виду -- проделаем те же действия, что и на прошлом семинаре. Загрузим базу данных (учтем кодировку!), выберем нужные переменные (столбцы) и присвоим им более содержательные названия.

```{r, message = FALSE}
library(dplyr)

el <- read.csv("47130-8314.csv", encoding = "UTF-8")

el <- el %>% select(kom1, kom2, kom3, X1, X9, X10, X19, X20, X21, X22, X23)
colnames(el) <- c("region", "tik", "uik", "total", "invalid", "valid",
                  "Zh", "Zu", "Mi", "Pr", "Pu")
```
Добавим переменную *turnout* (явка, число голосов) и *turnout_perc* (явка, в процентах). Удалим строки с пропущенными значениями и территорию за пределами РФ.
```{r}
el <- el %>% mutate(turnout = invalid + valid)
el <- el %>% mutate(turnout_perc = turnout / total * 100)
el <- el %>% filter(region != "Территория за пределами РФ", region != "Город Байконур (Республика Казахстан)")
el <- na.omit(el)
```

Агрегируем результаты по регионам (суммируем) и добавим показатели в процентах:

```{r}
aggr_reg  <- el %>% group_by(region) %>%
  summarise(total = sum(total),
            turnout = sum(turnout),
            Zh = sum(Zh),
            Zu = sum(Zu),
            Mi = sum(Mi),
            Pr = sum(Pr),
            Pu = sum(Pu)) 

aggr_reg <- aggr_reg %>% mutate(turnout_perc = turnout / total * 100, 
                     Zh_perc = Zh / turnout * 100, 
                     Zu_perc = Zu / turnout * 100, 
                     Mi_perc = Mi / turnout * 100,
                     Pr_perc = Pr / turnout * 100,
                     Pu_perc = Pu / turnout * 100)
```

Создадим переменную *reg_type* (тип региона), которая принимает значения "область", "республика", "край", "округ", "город". Сразу получить такую переменную не получится (нужны конструкции с условиями и циклы, а мы пока их не обсуждали), но можно поступить по-другому -- сначала создать дамми-переменные для каждого типа региона, а затем их скомбинировать. 

Что такое дамми-переменная (фиктивная переменная)? Переменная, которая принимает значение 1, если выполняется определенное условие, и значение 0 во всех остальных случаях. В нашем примере нам необходимо создать целый набор взаимоисключающих дамми-переменных: для республик, для областей, для округов, для краев и для городов (городов федерального значения). Давайте для простоты пока опустим автономную область (почему так проще, чуть позже поймем, а на семинаре сделаем все, как надо). 

Для поиска значений в текстовом векторе (столбце *region*) воспользуемся функцией `grepl()`. Работает она так: ходит по элементам вектора, если элемент содержит текст, который мы ищем (паттерн, частичное совпадение), то функция выдает TRUE, если нет -- FALSE, и так для всех элементов. Например:

```{r}
regs <- c("Белгородская область", "Владимирская область", "Кабардино-Балкарская Республика", "Город Москва")

grepl(pattern = "область", regs)
```

Видно, что функция `grepl` выдает логический вектор из TRUE и FALSE. Чтобы получить дамми-переменную из 0 и 1, нужно превратить этот вектор в целочисленный: 

```{r}
as.integer(grepl(pattern = "область", regs))
```

А теперь проделаем эти операции для разных типов регионов в нашей базе: 

```{r}
aggr_reg <- aggr_reg %>% mutate(resp = as.integer(grepl(pattern = "Республика", region)),
                     oblast = as.integer(grepl(pattern = "область", region)),
                     okrug = as.integer(grepl(pattern = "округ", region)),
                     krai = as.integer(grepl(pattern = "край", region)),
                     gorod = as.integer(grepl(pattern = "Город", region)))
View(aggr_reg)
```
Осталось скомбинировать полученные дамми-переменные -- создать переменную *reg_type*:

```{r}
aggr_reg$reg_type <- names(aggr_reg[15:19])[max.col(aggr_reg[15:19])]
```

Посмотрим на нашу базу данных: 

```{r}
View(aggr_reg)
```

Все получилось так, как и хотели. Но строчка с кодом выглядит для комбинации дамми-переменных выглядит загадочно. Чтобы разобраться, как она работает, посмотрим, каким образом мы "схлопываем" дамми-переменные. Последовательность действий такая.

*Код ниже -- для иллюстрации. Но с ним можно самим разобраться, работать с матрицами мы умеем. *

*Шаг 1.* У нас есть примерно такая база данных:

```{r, echo=FALSE}
m <- rbind(c(0, 1, 0, 0, 0),
c(1, 0, 0, 0, 0),
c(0, 0, 1, 0, 0),
c(0, 0, 0, 0, 1),
c(0, 0, 0, 1, 0))

colnames(m) <- c("gorod", "krai", "oblast", "okrug", "resp")
rownames(m) <- c("Алтайский край", "Город Москва", "Ивановская область", "Республика Коми", "Ненецкий автономный округ")

as.data.frame(m)
```

*Шаг 2.* Заменяем единички на названия столбцов, в котором они стоят:

```{r, echo=FALSE}
m1 <- rbind(c(0, "krai", 0, 0, 0),
c("gorod", 0, 0, 0, 0),
c(0, 0, "oblast", 0, 0),
c(0, 0, 0, 0, "resp"),
c(0, 0, 0, "okrug", 0))

colnames(m1) <- c("gorod", "krai", "oblast", "okrug", "resp")
rownames(m1) <- c("Алтайский край", "Город Москва", "Ивановская область", "Республика Коми", "Ненецкий автономный округ")

as.data.frame(m1)
```
Шаг 3. А теперь создаем для названий отдельный столбец и переносим все наименования в него:
```{r, echo=FALSE}
m2 <- rbind(c(0, "krai", 0, 0, 0),
c("gorod", 0, 0, 0, 0),
c(0, 0, "oblast", 0, 0),
c(0, 0, 0, 0, "resp"),
c(0, 0, 0, "okrug", 0))

m2 <- cbind(m2, c("krai", "gorod", "oblast", "resp", "okrug"))

colnames(m2) <- c("gorod", "krai", "oblast", "okrug", "resp", "reg_type")
rownames(m2) <- c("Алтайский край", "Город Москва", "Ивановская область", "Республика Коми", "Ненецкий автономный округ")

as.data.frame(m2)
```

Функция `max.col()` для каждой строки матрицы возвращает номер столбца, в котором находится максимальное значение по этой строке. В нашем случае -- это номер столбца, где стоит единичка (так как всего два значения, 0 и 1):

```{r}
max.col(m)
```

В первой строке 1 стоит на втором месте,  во второй -- на первом и так далее.

Дальше на соответствующие единичкам позиции мы ставим названия столбцов (`names()`) и собираем все в одну новую переменную `reg_type`.

## Качественные (номинальные) данные

Как мы уже обсуждали, для описания качественных показателей мы можем использовать частоты (абсолютные или относительные -- в долях или процентах). 

**Столбиковая диаграмма (bar plot)**

Обычная столбиковая диаграмма в R строится не для самой переменной, а для таблицы частот. С таблицей частот мы уже знакомы:

```{r}
table(aggr_reg$reg_type)
```

**Внимание:** в этой базе данных есть не все регионы, будьте внимательны и осторожны.

Столбиковая диаграмма строится вот так:

```{r}
barplot(table(aggr_reg$reg_type))
```

Диаграмма показывает, сколько регионов каждого типа в базе данных. Приведем график в порядок: добавим заголовок (`main`), и более внятные подписи к столбикам (`names.arg`).
```{r}
barplot(table(aggr_reg$reg_type), 
        main = "Типы регионов", 
        names.arg = c("город фед. \n знач.", "край", "область", "округ", "республика"))
```

Символ `\n` используется для переноса текста на новую строку -- название слишком длинное и не хочется, чтобы оно перекрывало остальные подписи.

Поменяем цвет графика (`col`) и добавим подпись к оси y (`ylab`):

```{r}
barplot(table(aggr_reg$reg_type), 
        main = "Типы регионов", 
        names.arg = c("город фед. \n знач.", "край", "область", "округ", "республика"),
        col = "red",
        ylab = "число регионов")
```

А теперь сделаем ось y более детальной -- добавим побольше делений. Для ручной корректировки осей есть специальная функция `axis()`, где первым аргументом идет номер оси (1 -- для оси x, 2 -- для оси y). 

**Внимание:** строка с `axis()` должна идти сразу после кода для построения самого графика, иначе R не поймет, к какому графику она относится, и выдаст ошибку. 

**Еще внимание:** если "выправляем" оси с помощью `axis()`, важно не забыть убрать оси на самом графике, иначе оси наложатся друг на друга, и это будет выглядеть странно.

```{r}
# строим график

barplot(table(aggr_reg$reg_type), 
        main = "Типы регионов", 
        names.arg = c("город фед. \n знач.", "край", "область", "округ", "республика"),
        col = "red",
        ylab = "число регионов", axes = FALSE) # axes = FALSE - убираем оси

# корректируем оси
# at - где ставим деления
# здесь - от 0 до 50 через каждые 5 единиц

axis(2, at = seq(from = 0, to = 50, by = 5))

```

А что если мы захотим получить столбчатую диаграмму, но не с абсолютными частотами (число регионов), а с относительными частотами (в процентах)?

Все просто: чтобы построить такой график, нужно создать таблицу с частотами в процентах -- взять таблицу, которую мы уже видели, поделить все частоты в ней на сумму значений и умножить на 100:

```{r}
tab <- table(aggr_reg$reg_type)
perc <- tab/sum(tab) * 100 

perc

barplot(perc)
```

А дальше приведем график в порядок:

```{r}
# строим график 
# ylim - границы значений по оси y (от 0 до 65)

barplot(perc, 
        main = "Типы регионов", 
        names.arg = c("город фед. \n знач.", "край", "область", "округ", "республика"),
        col = "red",
        ylim = c(0, 65),
        ylab = "доля регионов (в %)", 
        axes = FALSE)

# корректируем оси

axis(2, at = seq(from = 0, to = 65, by = 5))
```

А чтобы было совсем здорово, добавим подписи с процентами на сам график. Для этого сначала создадим вектор с подписями -- округлим значения в векторе perc и "приклеим" к каждому значению символ "%". 

```{r}
perc_labels <- round(perc, 2) # округляем
perc_labels <- paste(perc_labels, "%", sep = "") # приклеиваем знак %
```

В `paste()` мы добавили аргумент `sep`, чтобы указать разделитель. По умолчанию разделителем является пробел, а мы хотим, чтобы перед знаком процента пробела не было.

Теперь нанесем все на график -- добавим нужный нам текст (подписи). 

**Внимание: ** сначала нужно сохранить график в какую-нибудь переменную (pl), а затем указать ее в качестве аргумента функции `text()`.

```{r}
pl <- barplot(perc, 
        main = "Типы регионов", 
        names.arg = c("город фед. \n знач.", "край", "область", "округ", "республика"),
        col = "red",
        ylim = c(0, 65),
        ylab = "доля регионов (в %)", 
        axes = FALSE)

# корректируем оси

axis(2, at = seq(from = 0, to = 65, by = 5))

# добавляем подписи
# x - положение текста по оси x (здесь - столбцы графика)
# y - положение текста по оси y (здесь - высота столбцов, проценты)
# pos = 3 - текст помещается над координатами (x, y)

text(x = pl, y = perc, labels = perc_labels, pos = 3)
```

На этом с наведением красоты можно закончить и перейти к другим графикам. 

**Круговая диаграмма (pie chart)**

Круговая диаграмма строится для относительных частот -- для процентов. Таблицу для процентов мы уже построили (perc).

```{r}
pie(perc)
```

Пока выглядит грустно. Начинаем исправлять. Создадим вектор цветов для диаграммы:

```{r}
# да, я специально подобрала нетипичные названия цветов

colors <- c('thistle2', 'plum2', 'palevioletred', 'orchid4', 'purple3')

pie(perc, col = colors)
```

Какие цвета есть в R можно посмотреть [здесь](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf).


Добавим внятные подписи (как и в случае столбчатой диаграммы).
```{r}
labs = c("город федерального \n значения", "край", "область", "округ", "республика")

# в отличие от barplot, для надписей используем аргумент labels

pie(perc, col = colors, main = "Типы регионов", labels = labs)
```

Сильно красивее не стало.

Поэтому сделаем по-другому: на самом графике подпишем проценты (perc_labels), а остальное вынесем в легенду графика. 

**Внимание:** как в случаях с `axis()` и `text()` прописываем код для легенды `legend()` сразу после построения графика.

```{r}
pie(perc, col = colors, main = "Типы регионов", labels = perc_labels)

# легенда
# bottomleft - позиция легенды, нижний левый угол
# labs - названия, которые должны быть в легенде
# cex - размер шрифта для наименований в легенде, по умолчанию 1
# fill - цвета, соответствующие наименованиям

legend("bottomleft", labs, cex = 0.6, fill = colors)
```


## Количественные данные

**Гистограмма (histogram)**

Гистограмма -- график, который иллюстрирует соответствие между значениями количественной переменной и частотой, с которыми эти значения встречаются в выборке. 

Для начала построим самую простую гистограмму. Построим гистограмму для явки на выборы (по регионам).

```{r}
hist(aggr_reg$turnout_perc)
```

Теперь сделаем ее красивой: добавим название графика и подзаголовок, поменяем цвет и подпишем оси.
```{r}
hist(aggr_reg$turnout_perc,
     col = "lightgreen", 
     main = "Выборы президента 2012 года",
     xlab = "Явка (в %)", 
     ylab = "Частоты")
```

Что показывает эта гистограмма? Форму распределения явки на выборах. По гистограмме видно следующее:

* значения явки сконцентрированы в районе 55%--65% (часто встречающиеся значения)
* регионов с явкой менее 55% совсем мало (один)
* есть регионы с явкой выше 90% (четыре)

При построении гистограмм можно задействовать важный параметр -- `breaks`, число "разбивок", то есть "перегородок", которые нужно взять, чтобы поделить упорядоченную выборку на равные интервалы. Нетрудно догадаться, что число самих равных интервалов всегда будет на 1 меньше, чем число "перегородок".

*Пример:*

|2 2 | 3 5 | 6 8 | 9 10|

breaks = 5

число интервалов = 4 (число столбцов в гистограмме)


Сравним две гистограммы:

```{r}
hist(aggr_reg$turnout_perc, breaks = 10, col = "lightgreen")
hist(aggr_reg$turnout_perc, breaks = 20, col = "lightgreen")
```

Гистограммы внешне отличаются друг от друга. Но, на самом деле, это одна и та же гистограмма, просто с разными интервалами разбивки. На первой гистограмме ширина столбца равна 5, а на второй -- 2. Как правило, вопрос о том, какое число столбцов  гистограммы взять, не возникает, потому что R автоматически подбирает подходящее число столбцов. (По умолчанию используется алгоритм Стёржеса, кому интересно почитать про различные алгоритмы, см. [здесь](https://en.wikipedia.org/wiki/Histogram), Number of bins and width). Да, это Википедия, но там есть ссылки на оригинальные статьи про способы разбивки).

**Ящик с усами (boxplot)**

С помощью ящика с усами также можно представить распределение количественного показателя. В отличие от гистограммы, ящик с усами позволяет явно увидеть описательные статистики, посчитанные по переменной. Подробнее см. [здесь](https://ru.wikipedia.org/wiki/%D0%AF%D1%89%D0%B8%D0%BA_%D1%81_%D1%83%D1%81%D0%B0%D0%BC%D0%B8).
```{r}
# sub - подзаголовок

boxplot(aggr_reg$Zu_perc, 
        col = "tomato", 
        main = "Процент голосов",
        sub = 'Зюганов ("КПРФ")') 
```

Ящик с усами позволяет также определить, есть ли в выборке нетипичные значения (выбросы, outliers), то есть значения, которые сильно отличаются от остальных. В нашем случае такие наблюдения есть (точки, которые располагаются за пределами "усов" графика). Есть регионы, где за Зюганова проголосовало слишком мало избирателей или наоборот, слишком много. К сожалению, с помощью стандартной функции `boxplot()` мы не сможем отметить на графике, что это за регионы. Но к более "продвинутым" ящикам с усами мы еще вернемся, когда будем работать с библиотекой `ggplot2`.

```{r}
boxplot(aggr_reg$Zu_perc, 
        col = "tomato", 
        main = "Процент голосов",
        sub = 'Зюганов ("КПРФ")') 
```

**Скрипичная диаграмма (violin plot)**

Еще один тип графика, который используется для визуализаии распределения количественных данных, это скрипичная диаграмма (*violin plot*). Иногда из-за формы его называют *bean plot* (да, кто-то видит в графике скрипки, а кто-то бобы, так бывает). Чтобы понять, почему у графика такие специфические названия, давайте его построим.

Установим сначала библиотеку *vioplot*. 

```{r, eval=FALSE}
install.packages("vioplot")
```

И обратимся к ней.

```{r}
library(vioplot)
```

Построим скрипичную диаграмму для процента голосов за Зюганова. 

```{r}
vioplot(aggr_reg$Zu_perc, col = "tomato")
```

Получился питон, который проглотил ящик с усами! На самом деле, скрипичная диаграмма объединяет два графика: ящик с усами и график плотности распределения (сглаженный вариант гистограммы -- если повернем график на 90 градусов, увидим, что он состоит из двух одинаковых половинок, похожих на обведенную по контуру гистограмму). Несмотря на то, что график кажется необычным, он часто бывает достаточно полезен, особенно, когда нам важно показать форму распределения. По нашему графику мы видим две вещи: 1) проценты голосов за Зюганова в регионах, в целом, несильно отличаются от медианного значения; 2) есть несколько нетипичных регионов, где процент голосов за Зюганова слишком маленький -- у графика плотности есть небольшой "хвост" слева.   

А теперь посмотрим на скрипичную диаграмму для явки:

```{r}
vioplot(aggr_reg$turnout_perc, 
        col = "green")
```

Теперь мы видим пример распределения данных, у которого есть длинный <<хвост>> справа -- есть регионы, явка в которых превышает 90%. 

*Про скошенность распределения:* часто говорят *распределение показателя скошено вправо* или *распределение показателя скошено влево*. Как понять, в какую сторону распределение скошено? Просто: с какой стороны находится длинный "хвост", в ту сторону и скошено. В наших примерах распределение процента голосов за Зюганова несильно скошено влево, а распределение явки скошено вправо.  


